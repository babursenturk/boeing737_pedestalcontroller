;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USBFS_1.asm
;;   Version: 1.1, Updated on 2006/06/19 at 11:41:37
;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
;;
;;  DESCRIPTION: USB Device User Module software implementation file
;;               for the CY8C24090 and CY7C64215 family of devices
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2005. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "USBFS_1_macros.inc"
include "USBFS_1.inc"
IF 0x4 & 0x10000000
PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
; This message will only appear if the USB Setup Wizard has not be run and the descriptors
; and associated data structures have been created.
; After running the USB Setup Wizard, you must also select the Config/Generate Application
; menu item from PSoC Designer in order to generate USB User Module data structures and
; descriptors.
ENDIF
;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
EXPORT USBFS_1_Start
EXPORT _USBFS_1_Start
EXPORT USBFS_1_Stop
EXPORT _USBFS_1_Stop
EXPORT USBFS_1_bCheckActivity
EXPORT _USBFS_1_bCheckActivity
EXPORT USBFS_1_bGetConfiguration
EXPORT _USBFS_1_bGetConfiguration
EXPORT USBFS_1_bGetEPState
EXPORT _USBFS_1_bGetEPState
EXPORT USBFS_1_wGetEPCount
EXPORT _USBFS_1_wGetEPCount
EXPORT USBFS_1_LoadInEP
EXPORT _USBFS_1_LoadInEP
EXPORT USBFS_1_LoadInISOCEP
EXPORT _USBFS_1_LoadInISOCEP
EXPORT USBFS_1_EnableOutEP
EXPORT _USBFS_1_EnableOutEP
EXPORT USBFS_1_EnableOutISOCEP
EXPORT _USBFS_1_EnableOutISOCEP
EXPORT USBFS_1_DisableOutEP
EXPORT _USBFS_1_DisableOutEP
EXPORT USBFS_1_bReadOutEP
EXPORT _USBFS_1_bReadOutEP
EXPORT USBFS_1_Force
EXPORT _USBFS_1_Force
EXPORT USBFS_1_bGetEPAckState
EXPORT _USBFS_1_bGetEPAckState
;EXPORT USBFS_1_Suspend
;EXPORT _USBFS_1_Suspend
;EXPORT USBFS_1_Resume
;EXPORT _USBFS_1_Resume
EXPORT USBFS_1_bRWUEnabled
EXPORT _USBFS_1_bRWUEnabled

AREA InterruptRAM (RAM,REL,CON)
;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------

;-----------------------------------------------
;  Variable Allocation
;-----------------------------------------------
EXPORT USBFS_1_APITemp
 USBFS_1_APITemp:                       BLK   2 ; Two bytes of temporary
                                                ; storage shared by the API
                                                ; functions
EXPORT USBFS_1_APIEPNumber, _USBFS_1_APIEPNumber
_USBFS_1_APIEPNumber:
 USBFS_1_APIEPNumber:                  BLK   1 ; API storage for speed
EXPORT USBFS_1_APICount, _USBFS_1_APICount
_USBFS_1_APICount:
 USBFS_1_APICount:                     BLK   1 ; API storage for speed

EXPORT USBFS_1_bActivity
 USBFS_1_bActivity:                    BLK   1 ; Activity flag (Shared between the ISR and API)
;-----------------------------------------------
;  Constant Data Allocation
;-----------------------------------------------
AREA UserModules (ROM, REL)
EXPORT USBFS_1_USB_EP_BIT_LOOKUP
.LITERAL
USBFS_1_USB_EP_BIT_LOOKUP:  ;
    DB     01H                       ; EP0
    DB     02H                       ; EP1
    DB     04H                       ; EP2
    DB     08H                       ; EP3
    DB     010H                      ; EP4
.ENDLITERAL

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_Start
;
;  DESCRIPTION:    Starts the USB User Module
;                    Sets the device selection
;                    Set the configuration to unconfigured
;                    Enables the SIE for Address 0
;                    Enables the USB pullup (D- for low speed, D+ for full speed)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A is the desired device
;                X is the operation voltage
;
;  RETURNS:              Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_Start:
_USBFS_1_Start:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
        RAM_SETPAGE_CUR >USBFS_1_bCurrentDevice ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX >USBFS_1_bCurrentDevice ; Set the IDX_PP to the right page
    push    X
    mov     [USBFS_1_bCurrentDevice], A; The app selects the desired device

    mov     [USBFS_1_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
    mov     [USBFS_1_Configuration], 0 ; Unconfigured
    mov     [USBFS_1_DeviceStatus], 0  ; Clears device status

    MOV     [USBFS_1_EPDataToggle], 0  ; Clear all EP data toggles

    mov     reg[TMP_DR0], 0            ; EP1 start address in PMA space
        mov     reg[TMP_DR1], 64       ; EP2 start address in PMA space
        mov     reg[TMP_DR2], 128      ; EP3 start address in PMA space
        mov     reg[TMP_DR3], 192      ; EP4 start address in PMA space

;    mov     X, USB_MAX_EP_NUMBER      ; Set up loop to clear all of the endpoint data items
; Flow or jump here to clear the data for the next endpoint
;.loop:
;    mov     [X + USBFS_1_EPDataToggle], 0  ; Or in the toggle
;    dec     X                         ; Are we done?
;    jnz     .loop                     ; Jump to do another endpoint
; Flow here to enable the SIE

    mov     reg[USBFS_1_ADDR], USB_ADDR_ENABLE ; Enable Address 0
        mov     reg[USBFS_1_USBIO_CR0], USB_AUTO_DPDM

; Set the Operating Voltage at which the chip will run
    pop     A
    M8C_SetBank1
        mov     reg[USBFS_1_USB_CR1], A
        M8C_SetBank0
;   TODO
    mov     reg[USBFS_1_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
    M8C_EnableIntMask USBFS_1_INT_REG, (USBFS_1_INT_RESET_MASK | USBFS_1_INT_EP0_MASK)

;   Enable the pullup so we can start to rock and roll
    mov     reg[USBFS_1_USBIO_CR1], USB_PULLUP_ENABLE ; Pullup D+

    RAM_EPILOGUE RAM_USE_CLASS_3
        RAM_EPILOGUE RAM_USE_CLASS_4
    RET
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_Stop
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:   Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_Stop:
_USBFS_1_Stop:
    RAM_PROLOGUE RAM_USE_CLASS_4
        RAM_SETPAGE_CUR >USBFS_1_bCurrentDevice ; Set the CUR_PP to the right page

    mov     [USBFS_1_bCurrentDevice], 0; The app selects the desired device

    mov     [USBFS_1_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
    mov     [USBFS_1_Configuration], 0 ; Unconfigured
    mov     [USBFS_1_DeviceStatus], 0  ; Clears device status
    mov     reg[USBFS_1_ADDR], 0       ; Clear the addfress and Address 0

    and     reg[USBFS_1_USBIO_CR1], ~USB_PULLUP_ENABLE ; Release D-
    mov     reg[USBFS_1_INT_REG], 0x00 ; Enable the interrupt

        RAM_EPILOGUE RAM_USE_CLASS_4
    RET
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bCheckActivity
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: Nothing
;
;  RETURNS:   A is a flag that indicates bus activity
;
;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_bCheckActivity:
_USBFS_1_bCheckActivity:
    RAM_PROLOGUE RAM_USE_CLASS_1
    M8C_SetBank1
    mov    A, reg[USBFS_1_USB_CR1]     ; USB Activity bit indicates activity
    and    A, USB_BUS_ACTIVITY         ; Activity?
    jz     .no_activity                ; Jump on no activity?
; Flow here on bus activity
    mov    A, 1                        ; Return true
    jmp    .done
; Jump here on no activity
.no_activity:
    mov    A, 0                        ; Return false
; Jump or flow here to clear the activity bit, then return
.done:
    and    reg[USBFS_1_USB_CR1], ~USB_BUS_ACTIVITY  ; Clear the activity flag
    M8C_SetBank0
        RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bGetConfiguration
;
;  DESCRIPTION:   Returns the current configuration number
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None
;
;  RETURNS:      A contains the current configuration number
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_bGetConfiguration:
_USBFS_1_bGetConfiguration:
        RAM_PROLOGUE RAM_USE_CLASS_4
        RAM_SETPAGE_CUR >USBFS_1_Configuration
    mov     A,[USBFS_1_Configuration]
        RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bGetEPState
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the endpoint number
;
;  RETURNS:      A contains the endpoint state
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_bGetEPState:
_USBFS_1_bGetEPState:
    RAM_PROLOGUE RAM_USE_CLASS_3
        RAM_SETPAGE_IDX >USBFS_1_EndpointAPIStatus
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to enable an endpoint
    mov     X, A                       ; Endpoint number is the index
    mov     A, [X+USBFS_1_EndpointAPIStatus]; Get the state
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION



;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bRWUEnabled
;
;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:   None
;
;  RETURNS:     A: 1--Remote Wake Up Enabled
;                  0--Remote Wake Up Disabled
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.SECTION
 USBFS_1_bRWUEnabled:
_USBFS_1_bRWUEnabled:
    TST     [USBFS_1_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    JNZ     .enabled                   ; Jump if enabled
; Flow here if RWU is disabled
    MOV     A, 0                       ; Return disabled
    JMP     .exit                      ; Go to the common exit
; Jump when RWU is enabled
.enabled:
    MOV     A, 1                       ; Return enabled
; Jump or flow here for a common exit
.exit:
    RET                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bGetEPCount
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the Endpoint Number
;
;  RETURNS:              A and X contain a WORD that indicate the values stored in the
;                Count registers of the Endpoint
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
.SECTION
 USBFS_1_wGetEPCount:
_USBFS_1_wGetEPCount:
    RAM_PROLOGUE RAM_USE_CLASS_1
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to get the endpoint count
    asl     A                          ; Multiply the index by two to get to the value
    mov     X, A                       ; Endpoint number is the index
    mov     A, reg[X+USBFS_1_EP1CNT1 - 1] ; Here is the count
        sub     A, 2
    push    A
        dec     X
        mov     A, reg[X+USBFS_1_EP1CNT1 - 1] ; Here is the count
        and     A, 0x01
    mov     X, A
        pop     A
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_LoadInEP and USBFS_1_LoadInISOCEP
;
;  DESCRIPTION:    This function loads the specified USB endpoint with
;                  the data specified.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-8] Toggle
;     [SP-7] MSB of Count to send
;     [SP-6] LSB of Count to send
;     [SP-5] MSB of data array address
;     [SP-4] LSB of data array address
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_TYPE:        equ -1
; -2 and -3 is the return address to caller
EP_NUM:     equ -4                       ; Endpoint Number
DATA_LSB:   equ -5           ; LSB pointer of data
DATA_MSB:   equ -6           ; MSB pointer of data
CNTLEN_LSB: equ -7
CNTLEN_MSB: equ -8           ; Length of data to send
TOGGLE:     equ -9

 USBFS_1_LoadInISOCEP:
_USBFS_1_LoadInISOCEP:
        mov             A, USB_MODE_ISO_IN
        push    A
        jmp             BodyLoadIN_USBFS_1
 USBFS_1_LoadInEP:
_USBFS_1_LoadInEP:
        mov             A, USB_MODE_ACK_IN
        push    A
BodyLoadIN_USBFS_1:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
        RAM_SETPAGE_CUR >USBFS_1_bCurrentDevice ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK
        mov     X, SP
        mov     A, [X+EP_NUM]
        cmp     A, USB_MAX_EP_NUMBER+1 ; Range check
    jnc     .exit                      ; Bail out

    ;SET THE COUNT
        mov     A, [X+CNTLEN_MSB]      ; Get the MSB of the Count
        and     A, 0x01                ; Mask off the count bit
        mov     [USBFS_1_APITemp+1], A ; Save the count
        mov     A, [X+CNTLEN_LSB]      ; Get the LSB of the Count
        mov     [USBFS_1_APITemp], A   ; Save the count


        ;  Perform normal data toggle or bypass?
        mov     A, [X+TOGGLE]
        jnz      .normalToggle

		; the endpoint ISR automatically toggles the endpoint, so to support
		; the idea of not having the toggle change we must untoggle here.
        mov     A, [X+EP_NUM]           ; Get the Endpoint number
        INDEX   USBFS_1_USB_EP_BIT_LOOKUP ; Get the bit mask
        XOR     [USBFS_1_EPDataToggle], A ; Retoggle the toggle

.normalToggle:              
        mov     A, [X+EP_NUM]           ; Get the Endpoint number
        INDEX   USBFS_1_USB_EP_BIT_LOOKUP ; Get the bit mask
        AND     A, [USBFS_1_EPDataToggle]
        JZ      .toggle0

        OR      [USBFS_1_APITemp+1],USB_CNT_TOGGLE ; Set the data toggle
        JMP     .toggle_done
.toggle0:
        AND     [USBFS_1_APITemp+1],~USB_CNT_TOGGLE
                
.toggle_done:

    RAM_SETPAGE_IDX2STK
    mov     X, SP
        mov     A, [X+EP_NUM]           ; Get the Endpoint number
        asl     A                       ; Double the ep number for proper cnt access
        mov     X, A                    ; Make it into an index
        mov     A, [USBFS_1_APITemp]    ; Retrieve the saved MSB
    mov     reg[X+USBFS_1_EP1CNT1 - 1], A   ; Write it into the register
    dec     X                           ; Decrement the index to access the LSB
        mov     A, [USBFS_1_APITemp+1]  ; Retrieve the saved LSB
        mov     reg[X+USBFS_1_EP1CNT1 - 1], A   ; Write it into the register

; It's Time to move the data

; First we need to determine where within the PMA the EP Start Address is
        mov     X, SP                   ; Get the Stack Pointer
        mov     A, [X+EP_NUM]           ; Get the Endpoint number
        mov     X, A                    ; Use the EP number as an index
        mov     A, reg[X+TMP_DR0-1]     ; Get the address of ep from tmp register
        M8C_SetBank1
        mov     reg[PMA0_WA], A         ; Set the Write pointer of our pma to ep space
        M8C_SetBank0

; Now we are ready to start moving data
    mov     X, SP
        and     [X+CNTLEN_MSB], 0x01    ; Mask off the MSB bit
        jnz     .start_send             ; If it is high then we have 256 bytes
        mov     A, [X+CNTLEN_LSB]       ; Check the LSB register
        jz      .done                   ; If it is 0 then we have a 0 length packet
.start_send:
        mov     A, [X+DATA_LSB]
        push    A
IF SYSTEM_LARGE_MEMORY_MODEL
        mov     A, [X+DATA_MSB]
        mov     reg[IDX_PP], A
ENDIF
        pop     X

.loop:
        mov             A, [X]
        mov     reg[PMA0_DR], A
        inc     X
        dec     [USBFS_1_APITemp]
        jnz     .loop

        RAM_SETPAGE_IDX2STK
.done:
    mov     X, SP
        mov     A, [X+EP_NUM]
        mov     X, A
        RAM_SETPAGE_IDX >USBFS_1_EndpointAPIStatus
    mov     [X + USBFS_1_EndpointAPIStatus], NO_EVENT_PENDING ; Set the state
        M8C_SetBank1
        mov     A, reg[X+TMP_DR0-1]    ; Get the value of the PMA start Address
        mov     reg[X + PMA0_RA], A    ; Load it into EP PMA so pre-fetch occurs

        push    X
        RAM_X_POINTS_TO_STACKPAGE
    mov     X, SP
    mov         A, [X+EP_TYPE-1]
        pop             X
    mov     reg[X + USBFS_1_EP1MODE-1], A ; Enable the endpoint

        M8C_SetBank0

.exit:
        pop             A              ; Clean up EP_TYPE
    RAM_EPILOGUE RAM_USE_CLASS_3
        RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_EnableOutEP and
;                                 USBFS_1_EnableOutISOCEP
;
;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the endpoint number
;
;  RETURNS:        None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
USBFS_1_EnableOutISOCEP:
_USBFS_1_EnableOutISOCEP:
        mov             X, USB_MODE_ISO_OUT
        push    X
        jmp             BodyEnableOut_USBFS_1
 USBFS_1_EnableOutEP:
_USBFS_1_EnableOutEP:
        mov             X, USB_MODE_ACK_OUT
        push    X
BodyEnableOut_USBFS_1:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_IDX >USBFS_1_EndpointAPIStatus

    cmp     A, 0                       ; Can't enable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .exit                      ; Bail out
; Flow here to enable an endpoint
    mov     X, A                       ; Endpoint number is the index
    push    X
    mov     [X+USBFS_1_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
        mov     A, X
        asl     A
        mov     X, A
        mov     reg[X+EP1_CNT1-1], 64
        M8C_SetBank1
        pop     X
    mov     A, reg[X+TMP_DR0-1]
        mov     reg[X+PMA0_WA], A
    mov     A, reg[X+USBFS_1_EP1MODE-1]; Unlock the mode register
    pop         A

    mov     reg[X+USBFS_1_EP1MODE-1], A; Enable the endpoint
    M8C_SetBank0
    jmp         .DoneEnableOut
; Jump or flow here for a common exit
.exit:
        pop             A
.DoneEnableOut:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_DisableEP
;
;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A the endpoint number
;
;  RETURNS:               none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
.SECTION
 USBFS_1_DisableOutEP:
_USBFS_1_DisableOutEP:
    cmp     A, 0                       ; Can't disable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .exit                      ; Bail out
; Flow here to disable an endpoint
    mov     X, A                       ; Endpoint number is the index
    M8C_SetBank1
    mov     A, reg[X+USBFS_1_EP1MODE-1]; Unlock the mode register
    mov     reg[X+USBFS_1_EP1MODE-1], USB_MODE_NAK_OUT ; Disable the endpoint
    M8C_SetBank0
; Jump or flow here for a common exit
.exit:
    ret                                ; All done
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_Force
;
;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A: USB_FORCE_J
;                    USB_FORCE_K
;                    USB_FORCE_SE0
;                    USB_FORCE_NONE
;
;  RETURNS:       Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_Force:
_USBFS_1_Force:
    mov    reg[USBFS_1_USBIO_CR0], A
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bReadOutEP
;
;  DESCRIPTION:    This function reads the data from the USB Out endpoint
;                  and loads it into the specified buffer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-7] MSB of Count to read
;     [SP-6] LSB of Count to read
;     [SP-5] MSB of data array address to put data in
;     [SP-4] LSB of data array address to put data in
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_NUMR:     equ -3                       ; Endpoint Number
DATA_LSBR:   equ -4           ; MSB pointer of data
DATA_MSBR:   equ -5           ; LSB pointer of data
CNTLEN_LSBR: equ -6           ; Length of data to send
CNTLEN_MSBR: equ -7

 USBFS_1_bReadOutEP:
_USBFS_1_bReadOutEP:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
        RAM_SETPAGE_CUR >USBFS_1_bCurrentDevice ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK
        mov     X, SP
        mov     A, [X+EP_NUMR]
        CMP     A, USB_MAX_EP_NUMBER+1 ; Range check
    JNC     .exit                      ; Bail out

    ;Get the count value passed
        mov     A, [X+CNTLEN_MSBR]     ; Get the MSB of the Count
        and     A, 0x01                ; Mask off the count bit
    mov     [USBFS_1_APITemp], A       ; Save the count
        mov     A, [X+CNTLEN_LSBR]     ; Get the LSB of the Count
        mov     [USBFS_1_APITemp+1], A   ; Save the count

    ;Determine which is smaller the requested data or the available data
        mov     A, [X+EP_NUMR]          ; Get the Endpoint number
        asl     A                       ; Double the ep number for proper cnt access
        mov     X, A                    ; Make it into an index
        mov     A, reg[X+USBFS_1_EP1CNT1 - 2]   ; Get the Real count MSB
        and     A, 0x01                 ; Mask off the LSB
        cmp     A, [USBFS_1_APITemp]    ; Are they equal
        jz      .MSBEqual               ; If they are check if they are 1
        jc      .CountDetermined        ;If the requested count is smaller use it
        mov     [USBFS_1_APITemp], A    ; Else use the actual
        mov     A, reg[X+USBFS_1_EP1CNT1 - 1]   ; Get the Real count LSB
        mov     [USBFS_1_APITemp + 1], A   ; Else use the actual
    jmp     .CountDetermined
.MSBEqual:
    mov     A, [USBFS_1_APITemp]
    jz      .CheckLSB
    mov     [USBFS_1_APITemp + 1], 0
    jmp         .CountDetermined
.CheckLSB:
        mov     A, reg[X+USBFS_1_EP1CNT1 - 1]   ; Get the Real count LSB
        cmp     A, [USBFS_1_APITemp+1]  ; Are they equal
        jz      .CountDetermined        ; If they are check if they are 1
        jnc      .CountDetermined       ;If the requested count is smaller use it
        mov     [USBFS_1_APITemp+1], A  ; Else use the actual
.CountDetermined:

; First we need to determine where within the PMA the EP Start Address is
        mov     X, SP                   ; Get the Stack Pointer
        mov     A, [X+EP_NUMR]          ; Get the Endpoint number
        mov     X, A                    ; Use the EP number as an index
        mov     A, reg[X+TMP_DR0-1]     ; Get the address of ep from tmp register
        M8C_SetBank1
        mov     reg[PMA0_RA], A         ; Set the Read pointer of our pma to ep space
        M8C_SetBank0

; Now we are ready to start moving data
        and     [USBFS_1_APITemp], 0x01   ; Mask off the MSB bit
        jnz     .start_send             ; If it is high then we have 256 bytes
        mov     A, [USBFS_1_APITemp+1]  ; Check the LSB register
        jz      .done                   ; If it is 0 then we have a 0 length packet

.start_send:
    mov     X, SP
        mov     A, [X+DATA_LSBR]        ; Get the LSB of the pointer
        push    A                       ; save on stack
IF SYSTEM_LARGE_MEMORY_MODEL
        mov     A, [X+DATA_MSBR]        ; Get the MSB of the pointer
        mov     reg[IDX_PP], A          ; Use as value for IDX_PP
ENDIF
        pop     X                       ; Get the LSB again

        ;;
        ;; 24Mhz read PMA workaround (kvn)
        ;;
        M8C_SetBank1
        mov A, reg[OSC_CR0]
        push A
        and A, 0xf8 ;clear the clock bits (briefly chg the cpu_clk to 3Mhz)
        or A, 0x02 ;will set clk to 12Mhz
        mov reg[OSC_CR0],A ;clk is now set at 12Mhz
        M8C_SetBank0

.loop:
        mov     A, reg[PMA0_DR]         ; Get the data from the PMA space
        mov             [X], A          ; save it in data array
        inc     X                       ; increment the pointer
        dec     [USBFS_1_APITemp+1]     ; decrement the counter
        jnz     .loop                   ; wait for count to zero out

        ;;
        ;; 24Mhz read PMA workaround (back to previous clock speed (kvn)
        ;;
        pop A ;recover previous reg[OSC_CR0] value
        M8C_SetBank1
        mov reg[OSC_CR0],A ;clk is now set at previous value (probably 24Mhz)
        M8C_SetBank0
        ;;
        ;; end 24Mhz read PMA workaround (kvn)
        ;;

        RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUMR]
        asl     A
        mov     X, A
    mov     A, reg[X+USBFS_1_EP1CNT1 - 1]   ; Get the Real count LSB
        sub     A, 2
.done:
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
        RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_1_bGetEPAckState
;
;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
;                 an endpoint
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A is the Endpoint Number
;
;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_1_bGetEPAckState:
_USBFS_1_bGetEPAckState:
    mov    X, A
        M8C_SetBank1
    mov    A, reg[X + USBFS_1_EP1MODE-1]
        M8C_SetBank0
    and    A, 0x10
    ret                                ; Exit
.ENDSECTION
